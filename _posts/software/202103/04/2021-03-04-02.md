---
layout: blog
istop: true
isshow: true
software: true
newstype: reprint
background: green
title:  "MVCC"
date:   2021-03-04
category: software
tags:
- Mysql
- MVCC
---

# MVCC
## 简介
`MVCC`，全称 `Multi-Version Concurrency Control`，即 `多版本并发控制`。`MVCC` 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。

## 作用
在 `Mysql` 的 `InnoDB引擎` 中就是指在 `已提交读(READ COMMITTD)` 和 `可重复读(REPEATABLE READ)` 这两种隔离级别下的事务对于`SELECT` 操作会访问版本链中的记录的过程。

这就使得别的事务可以修改这条记录，反正每次修改都会在版本链中记录。`SELECT` 可以去版本链中拿记录，这就实现了读-写，写-读的并发执行，提升了系统的性能。

# 版本链

> 我们先来理解一下版本链的概念。在InnoDB引擎表中，它的聚簇索引记录中有两个必要的隐藏列：

* **trx_id**
这个 `id` 用来存储的每次对某条 `聚簇索引` 记录进行修改的时候的 `事务id`。

* **roll_pointer**
每次对哪条聚簇索引记录有修改的时候，都会把老版本写入 `undo日志` 中。这个 `roll_pointer` 就是存了一个指针，它指向这条 `聚簇索引` 记录的上一个版本的位置，通过它来获得上一个版本的记录信息。(注意插入操作的 `undo日志` 没有这个属性，因为它没有老版本)  

| id | name | trx_id | roll_pointer |
| :---- | :---- | :---- | :---- |
| 1 | feng | 50 | 上一个版本的地址 |

比如现在有个事务id是60的执行的这条记录的修改语句  

| 事务 id 60 |
| :---- |
| update table set name = 'feng1' where id = 1 |

此时在 `undo日志` 中就存在版本链  

| id | name | trx_id | roll_pointer |
| :---- | :---- | :---- | :---- |
|  |  |  |  |
| 1 | feng1 | 60 | 上一个版本的地址 |
|  |  |  |  |
| 1 | feng | 50 |  |

## ReadView

**已提交读和可重复读的区别就在于它们生成ReadView的策略不同。**

`ReadView` 中主要就是有个列表来存储我们系统中当前活跃着的读写事务，也就是 `begin` 了还未提交的事务。通过这个列表来判断记录的某个版本是否对当前事务可见。假设当前列表里的 `事务id` 为[80,100]。  

* 如果你要访问的记录版本的 `事务id` 为50，比当前列表最小的id80小，那说明这个事务在之前就提交了，所以对当前活动的事务来说是可访问的。  
* 如果你要访问的记录版本的 `事务id` 为70,发现此事务在列表id最大值和最小值之间，那就再判断一下是否在列表内，如果在那就说明此事务还未提交，所以版本不能被访问。如果不在那说明事务已经提交，所以版本可以被访问。  
* 如果你要访问的记录版本的 `事务id` 为110，那比事务列表最大id100都大，那说明这个版本是在 `ReadView` 生成之后才发生的，所以不能被访问。  

这些记录都是去版本链里面找的，先找最近记录，如果最近这一条记录 `事务id` 不符合条件，不可见的话，再去找上一个版本再比较当前 `事务的id` 和这个版本 `事务id` 看能不能访问，以此类推直到返回可见的版本或者结束。

举个例子 ，在已提交读隔离级别下：

比如此时有一个 `事务id` 为100的事务，修改了 `name` ,使得的 `name` 等于 feng2 ，但是事务还没提交。则此时的版本链是

| id | name | trx_id | roll_pointer |
| :---- | :---- | :---- | :---- |
|  |  |  |  |
| 1 | feng2 | 100 | 上一个版本的地址 |
|  |  |  |  |
| 1 | feng1 | 60 | 上一个版本的地址 |
|  |  |  |  |
| 1 | feng | 50 |  |

那此时另一个事务发起了 `select` 语句要 `查询id` 为1的记录，那此时生成的 `ReadView` 列表只有[100]。那就去版本链去找了，首先肯定找最近的一条，发现 `trx_id` 是100,也就是 `name` 为 feng2 的那条记录，发现在列表内，所以不能访问。

这时候就通过指针继续找下一条，`name` 为feng1的记录，发现 `trx_id` 是60，小于列表中的最小id,所以可以访问，直接访问结果为 feng1。

那这时候我们把 `事务id` 为100的事务提交了，并且新建了一个 `事务id` 为110也修改id为1的记录，并且不提交事务


| 事务 id 110 |
| :---- |
| BEGIN; |
| update table set name = 'feng3' where id = 1; |

这时候的版本链就是

| id | name | trx_id | roll_pointer |
| :---- | :---- | :---- | :---- |
|  |  |  |  |
| 1 | feng3 | 110 | 上一个版本的地址 |
|  |  |  |  |
| 1 | feng2 | 100 | 上一个版本的地址 |
|  |  |  |  |
| 1 | feng1 | 60 | 上一个版本的地址 |
|  |  |  |  |
| 1 | feng | 50 |  |

这时候之前那个 `select` 事务又执行了一次查询,要查询id为1的记录。

这个时候关键的地方来了

如果你是
已提交读隔离级别，这时候你会重新一个 `ReadView`
，那你的活动事务列表中的值就变了，变成了[110]。

按照上的说法，你去版本链通过 `trx_id` 对比查找到合适的结果就是 feng2。

如果你是
可重复读隔离级别，这时候你的 `ReadView` 还是第一次 `select` 时候生成的 `ReadView`,
也就是列表的值还是[100]。所以 `select` 的结果是 feng1。所以第二次 `select` 结果和第一次一样，所以叫可重复读！

也就是说 `已提交读隔离` 级别下的事务在每次查询的开始都会生成一个独立的 `ReadView`,而 `可重复读隔离` 级别则在第一次读的时候生成一个`ReadView`，之后的读都复用之前的 `ReadView`。

这就是 `Mysql` 的 `MVCC`,通过 `版本链`，实现多版本，可并发 `读-写`，`写-读`。通过 `ReadView` 生成策略的不同实现不同的隔离级别。

# 原文链接
谈谈你对Mysql的MVCC的理解：[https://baijiahao.baidu.com/s?id=1629409989970483292&wfr=spider&for=pc](https://baijiahao.baidu.com/s?id=1629409989970483292&wfr=spider&for=pc)